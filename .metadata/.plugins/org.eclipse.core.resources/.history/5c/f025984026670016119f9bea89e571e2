/*
 * main.c
 *
 *  Created on: July 21, 2014
 *      Author: ewillcox
 */
/* to test boards
Step 1: upload this code
step 2: Connect a functional arm
Lower link: DSUB0
Upper link: DSUB1
Step 3 connect board to putty
Step 4 check putty output of timer, encoders, and potentiometers(AVR analog pins 2 and 3)
step 5 Add power to the screw terminal 7.2V (arm should home to a near vertical position)
step 6 test coprocessor by connecting vex motor to the servo ports. motor should rotate
step 7 connect switches to leds to test
step 8 use oscilliscope to test the current sensors. if good, 2.5v analog signal. If broken, sine wave.

*/


#include "RBELib/RBELib.h"
//For use of abs()
#include <stdlib.h>

//Globals
//Timer0
//volatile unsigned long counter = 0;
//volatile unsigned long millisecond = 0;
//ADC
//volatile int ADCval = 0;

char inchar;

int main(void)
{
	  //Enable printf() and setServo()
	  initRBELib();
	  //Set the baud rate of the UART
	  debugUSARTInit(115200);
	  printf("this is the beginning \n\r");
	  	  while(1)
	  	  {
	  		  inchar = getCharDebug();
	  		  _delay_ms(50);
	  		  printf("this is the middle and it goes on and on my friends and on and on again until it ends \n\r");

	  		if (inchar == 'A')
	  		{
	  			printf("This is the end! \n\r");
	  		}
	  	  }
}

/*
//Timer ISR
ISR(TIMER0_OVF_vect){
  //Using a prescaler of 8
  // ((18432000 / 8) / 256) / 1000 = 9 interrupts in a ms
  counter++;
  if(counter >= 9){
    millisecond++;
    counter = 0;
  }
}

//ADC ISR
ISR(ADC_vect){
  //Get low byte first
  int lower = ADCL;
  //Get high byte and free the ADC mem
  int upper = ADCH;

  //Combine the two values into a 10-bit result
  ADCval = ((upper & 0x03) << 8) | lower;
}

//Makes the arm drive to a relatively straight up position
void centerArm(int lowADC, int highADC){
  //Do a P(ID) calc and find the error
  volatile signed int lowPID = 10 * (550 - lowADC);
  volatile signed int highPID = 5 * (550 - highADC);

  //Check if the lower link ADC value is between 500 - 700
  //and drive the appropriate direction to make it
  if(lowADC < 650){
    setDAC(0, abs(lowPID));
    setDAC(1, 0);
  }
  else if (lowADC > 700){
    setDAC(0, 0);
    setDAC(1, abs(lowPID));
  }
  //If we're in the O.K. zone, stop the motors
  else{
    setDAC(0, 0);
    setDAC(1, 0);
  }

  //Check if the upper link ADC value is between 500 - 700
  if(highADC < 550){
    setDAC(2, 0);
    setDAC(3, abs(highPID));
  }
  else if(highADC > 600){
    setDAC(2, abs(highPID));
    setDAC(3, 0);
  }
  //If we're in the O.K. zone, stop the motors
  else{
    setDAC(2, 0);
    setDAC(3, 0);
  }

}

int main(void){
	//	PORTDbits._P7 = OFF;

  //Enable printf() and setServo()
  initRBELib();
  //Set the baud rate of the UART
  debugUSARTInit(115200);
  //Init timer 0
  initTimer(0,0,0);
  //Init the ADC to read channel 4
  initADC(4);
  //Init the SPI
  initSPI();
  //Init encoders
  encInit(0);
  encInit(1);
  //Enable interrupts

  // accel
  /*
   	while(1){
	x = GetAccelerationH48C(0);
	y = GetAccelerationH48C(1);
	z = GetAccelerationH48C(2);
	//printfDEBUG_NNL(", ");
				printfDEBUG_UL(x);
				printfDEBUG_NNL(", ");
				printfDEBUG_UL(y);
				printfDEBUG_NNL(", ");
				printfDEBUG_UL(z);
				printfDEBUG_NNL("\r\n");
				_delay_ms(40);
	}
}


  DDRBbits._P4 = 1;
 // PORTB = 0b00000000;
//while(1){

PORTBbits._P4 = 0;
_delay_ms(100);
//PORTBbits._P4 = 1;
//_delay_ms(100);
//}

  sei();
setServo(0,180);
_delay_ms(1);
setServo(1,0);
_delay_ms(1);
setServo(2,180);
_delay_ms(1);
setServo(3,180);
_delay_ms(1);
setServo(4,180);
_delay_ms(1);
  //Var for running at a set freq (ideally)
  unsigned long start = 0;
  while(1){
    //If 1 sec has passed since time we went into the if()...
    if(millisecond - start >= 750){
      //Sample the lower link
      changeADC(2);
      //Wait a little bit before sampling
      //Need to wait 25 cycles, just used some
      //random delay instead of doing the math...
      _delay_ms(75);
      //Grab the encoder count for the lower link
      signed int lowENC = encCount(0);
      //Grab the ADC value for the lower link
      volatile int lowADC = ADCval;

      //Switch to the ADC for the upper link
      ADMUX = (0x40) | 3;
      //Delay before sampling
      _delay_ms(75);
      //Grab the upper encoder count
      signed int highENC = encCount(1);
      //Grab the upper ADC count
      volatile int highADC = ADCval;

      //Print out all of the values we just sampled
      printf("\n\rTime: %9lu\tE0: %4d\tE1: %4d\n\r",
          millisecond, lowENC, highENC);
      printf("\t\tA0: %4d\tA1: %4d\n\r", lowADC, highADC);

      //Make the arm go relatively straight up
      centerArm(lowADC, highADC);

      start = millisecond;
    }
  }
  return 0;
}
*/
